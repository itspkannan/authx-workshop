TERRAFORM_DIR := terraform
TERRAFORM_IMAGE = hashicorp/terraform:1.8
DOCKER_NETWORK = auth_network
PROJECT = authx
DOCKER_COMPOSE_CMD = docker compose -p $(PROJECT)
TF_LOG = ERROR
KEYCLOAK_HOSTNAME=authx.provider.local
KEYCLOAK_PORT=8080
KEYCLOAK_URL=http://$(KEYCLOAK_HOSTNAME):$(KEYCLOAK_PORT)

include .env
export $(shell sed 's/=.*//' .env)

.DEFAULT_GOAL := help

.PHONY: help
help: ## üìñ Print help message
	@echo "\n\033[1;33mAvailable commands:\033[0m" \
	    && awk -F ':.*## ' '/^[a-zA-Z0-9_.-]+:.*## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) \
	    | sort && echo ""

.PHONY: create.network
create.network: ## üåê Create a network
	@echo "[INFO] Creating docker network $(DOCKER_NETWORK)."
	@docker network create $(DOCKER_NETWORK) || true

init.keycloak: create.network ## üõ†Ô∏è Provision Keycloak Service
	@DOCKER_NETWORK=$(DOCKER_NETWORK) $(DOCKER_COMPOSE_CMD)  up -d

debug.env:
	@cd terraform && docker run --rm --env-file $(PWD)/.env --network $(DOCKER_NETWORK) busybox env

wait.keycloak:
	@echo "‚è≥ Waiting for Keycloak..."
	@until docker run --env-file .env --rm --network $(DOCKER_NETWORK) curlimages/curl:latest \
		-s $(KEYCLOAK_URL)/realms/master/.well-known/openid-configuration > /dev/null; do \
		printf "."; sleep 5; \
	done; \
	echo "\n‚úÖ Keycloak is ready."

start.keycloak: create.network ## ‚ñ∂Ô∏è Start Keycloak Service
	@DOCKER_NETWORK=$(DOCKER_NETWORK) $(DOCKER_COMPOSE_CMD)  up -d

stop.keycloak: ## ‚èπÔ∏è Stop Keycloak Service
	@DOCKER_NETWORK=$(DOCKER_NETWORK) $(DOCKER_COMPOSE_CMD) down

init.terraform: ## üì¶ Initialize terraform Provider
	@docker run --rm -v $(PWD)/terraform:/workspace -e TF_LOG=$(TF_LOG) \
		 -w /workspace --network $(DOCKER_NETWORK) --env-file $(PWD)/.env $(TERRAFORM_IMAGE) init

plan.terraform: ## üì¶ Plan to check the changes
	@docker run --rm -v $(PWD)/terraform:/workspace -e TF_LOG=$(TF_LOG) \
		 -w /workspace --network $(DOCKER_NETWORK) --env-file $(PWD)/.env $(TERRAFORM_IMAGE) plan

apply.terraform: ## ‚öôÔ∏è Apply terraform configuration
	@docker run --rm -v $(PWD)/terraform:/workspace \
		-e TF_LOG=$(TF_LOG) -w /workspace --network $(DOCKER_NETWORK) $(TERRAFORM_IMAGE) apply -auto-approve

taint.user:
	@docker run --rm -v $(PWD)/terraform:/workspace \
		-e TF_LOG=$(TF_LOG) -w /workspace --network $(DOCKER_NETWORK) $(TERRAFORM_IMAGE) taint module.user.keycloak_user.testuser


output.terraform: ## ‚öôÔ∏è Output terraform configuration
	@docker run --rm -v $(PWD)/terraform:/workspace \
		-e TF_LOG=$(TF_LOG) -w /workspace --network $(DOCKER_NETWORK) $(TERRAFORM_IMAGE) output

generate.env: ## üß™ Generate .env file from Terraform outputs
	@echo "[INFO] Generating .env from terraform output..."
	@docker run --rm -v $(PWD)/terraform:/workspace -w /workspace \
		$(TERRAFORM_IMAGE) output -json \
		| jq -r 'to_entries[] | "\(.key | ascii_upcase)=\(.value.value)"' > .env.generated
	@echo "[INFO] Generated .env.generated"
	
init: init.keycloak wait.keycloak init.terraform plan.terraform apply.terraform

clean.terraform:  ## üßº Cleanup all the terraform files created
	@docker run --rm -v $(PWD)/terraform:/workspace -w /workspace \
	--network $(DOCKER_NETWORK) --env-file $(PWD)/.env $(TERRAFORM_IMAGE) init && \
	docker run --rm -v $(PWD)/terraform:/workspace -w /workspace \
	--network $(DOCKER_NETWORK) --env-file $(PWD)/.env $(TERRAFORM_IMAGE) destroy -auto-approve || true
	@rm -rf terraform/.terraform terraform/terraform.tfstate*

clean.keycloak: ## üßº Clean up Keycloak container and volume
	@docker volume rm keycloak_data || true

clean: clean.terraform stop.keycloak clean.keycloak ## üßº Cleanup all the resources created

.PHONY: test
test: ## üß™ Test the setup
	echo "üöÄ Attempting token retrieval..."
	max_retries=3; \
	count=0; \
	while true; do \
	  response=$$(docker run --env-file .env --rm --network $(DOCKER_NETWORK) curlimages/curl:latest \
	    -s -o /dev/null -w "%{http_code}" \
	    -X POST ${KEYCLOAK_URL}/realms/${REALM}/protocol/openid-connect/token \
	    -H "Content-Type: application/x-www-form-urlencoded" \
	    -d "client_id=${CLIENT_ID}" \
	    -d "client_secret=${CLIENT_SECRET}" \
	    -d "username=${USERNAME}" \
	    -d "password=${PASSWORD}" \
	    -d "grant_type=password"); \
		echo  response ;\
	  if [ "$$response" = "200" ]; then \
	    echo "‚úÖ Token retrieval successful!"; \
	    break; \
	  fi; \
	  count=$$((count + 1)); \
	  if [ $$count -ge $$max_retries ]; then \
	    echo "‚ùå Token retrieval failed after $$max_retries attempts."; \
	    exit 1; \
	  fi; \
	  echo "‚è≥ Retry $$count of $$max_retries..."; \
	  sleep 2; \
	done